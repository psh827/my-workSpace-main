09:00 1교시
도메인 부터 만드는 이유
기본적으로 어플리케이션은 화면이죠? 그것이 다른것과 구분되는 것인데 사실 그렇지않다
화면이 굉장히 중요한 요소인건 맞는데 it사람들이 비싼 돈을 받는 이유는 복잡성을 다루기때문
우리가 소위 복잡성을 다루는게 굉장히 많다 공학은 다 그럼. 기계, 토목 등등
소프트공학은 한가지 차이가 있다. 우리들건  끝까지 눈에 안보임 건물은 올라가는게 보인다 트럭이 지나갓네 층이 올라갓네 등등
그걸보면서 작업지시를 시킬 수 있음 소프트공학은 100% 머리속에서 이루어짐.
그래서 그거를 어떻게든 가시화 해야된다. 눈에 보이게 만들어야된다. 머리속에서는 한계가 있음
어떻게든 뽑아내서 가시화 해야됨 주석쓰고, 그림그리는거고, 네이밍 규칙 지키라고 하는거고 근데 사람들이 우습게 봄.
네이밍 왜중요? 왜? 팩트만 날려버리니깐 뽑아내야된다.
우리는 그래서 문서로 사는 사람들 코드도 문서다. 파워포인트도 확장자를 가진 파일이다. 폴드체계도 마찬가지 다 규칙이 있다.
여기서 저 도메인은 우리가 만들고자하는 어플리케이션에 있어서 가장 중요한 키워드를 가지고 이 키워드를 제외하고서는 이야기가 안되는것
이것을 도메인 펌? 이라고함. 쇼핑몰을 만든다 교보문고가 와서 서점만들어달라 온라인 북스토어 그럼 여기서 책이란게 빠지고 이야기가 되라? 아노딤
뱅킹을하는데 계좌와 고객을빼고 이야기가 됨? 안됨. 무엇이 도메인의 키가 될것이라는 것은 분석가에 의해서 추출되어짐 상상으로 추출되어지는게 아니고
그 이전에 요구사항을 정리한 사람에 의해서 이절차가 이루어짐. 요구사항은 어떻게 정리하느냐하면 프로젝트의 당사자를 만나서 인터뷰, 자료받아서 입수
이 모든게 커뮤니케이션 능력 . 크게 두가지 하나는 말하는 능력, 하나는 글을 쓰는 능력. 말하는거랑 쓴것을 적절히 문서화 해서 수많은 사람들에게 공유되게 만들어ㅑㅇ하ㅓㅁ.
공학을 하는 사람들은 언어를 배운다. 수학이라는. 경영은 다 경영의 언어를 배움. 자바니 스크립트니 이렇게 보지말고 현재 하는것이 어떤 위치를 가지고잇고
이것을 가지고 뭘 할 수 있는지도 알아야함. 
소개팅을 갓어 여자를 만낫는데 차임 소개시켜준사람한테 왜참? 뭔가 이야기하겟지? 근데 이야기하면서 이야기됨. 차야겟다고 그리고 말할때는 설득력있게 말하는건
저 결정에대한 변명. 무의식을 위한 의식의 변명? 가장중요한건 저사람이 필요한 사람인가? 그건 뭐냐면 저사람이 현재상황에서 옥죄고 있는 회사의 상황들.
현재 이 기업에서 어디에 프로젝트가 있는지 조사 안함. 회사 연혁, 성장, 서비스 이런것만 본다. 이 회사가 어떤 티오가 나거나 왜 났나를 판단해야된다.

10:13 2교시
무엇을 제일 먼저 만들어야할까? 뱅킹시스템을 만든다고 합시다 그런모드로 들어왔고 요구사항이 나왔고 이제 개발하자 팀장이야 작업지시를내려야해 무엇을 만들어야할까
여러가지가 있는데 Account는 account존재만으로 불가 고객이있어야함 그래서 고객이 기본 데이터. 
가장 기본적인 데이터부터 만드는것이 접근하기가 쉽다.

customer 복사해서 domain에 붙여넣기 account는 뒤에 만들어진거다
생성자부터 보면 그때마다 새로운생성자가 추가되기도 함.
지금 customer에보면 customerId가 있죠 이거는 뭘 염두해두고 만든거냐면 온라인상으로 염두하고 만든것 우리가 온라인상에서 접근할대 아이디와 패스워드를 묻기때문
저 customerId는 문제가있다 어떤거냐면 이미 데이터베이스로 조인도하고 했는데 테이블의관계에 있어서 account가 customer id를 폴인키로 받아서 customerid로 만들었음.
실제 정체는 customer의 cid 여기의 customerid는 소위 말하는 로긴말하는 userid 그니깐 헷갈림 이런게 있으면 빨리 조정들어가야된다.

어카운트도 복사해서 에러를 없애자 
어카운트는 추상으로 둘 수 있다 어카운트라는 계좌는 없이 세이빙 체킹만 있다 추상으로 뒀으면 지울 필요 없다.
거기안에 추상매소드가 있다면 그거 또한 지울 필요가 없다..

세이빙 체킹도 복사해볼까요
저같은 경우에는 상수값을 만들엇어요 그때 만들었는거죠 지금은 이부분을 안할게요 다른데소 사용하럭같아
exception패키지에 ㅇ{외 넣고ㅑ import하기
자 그다음에 지금부터 조금 어려워요
지금부터 하는건 기존에 없었던거야 없엇던거기 때문에 그냥 한번 만들어본건데 
도메인다음 만들건 dao를 만들거야 
dao눌러서 new class 
DataSourceManager
저번에 dao때 공통정보가 여러개 있어서 그런걸 없애기위해서 하는거야


private static final String JDBC_URL;
private static final String JDBC_USER;
private static final String JDBC_PASSWD;

왜 에러가 뜨나면 final 때문에 final하려면 선언과 동시에 초기화를 해줘야함 안해준다는건 최소한 생성자에서 해줘야한다.
생성자가 왜필요하냐면 그때 객체를 만드는거잖아 객체가 만들어지기전에 해야된다는거야 첨부터 가져가던지 최;소한 객체를 사용하기 전까지는 넣어라 이말이지 
객체를 만들고 난뒤에 하면 안된다는 거지 지금 초기화가 안됐지.
그런데 초기화가 안됐어 그러면은 내가지금 하기싫어 저시점에 하기싫어 어떻게 해야될까? 
왜냐면 아직 할 준비가 안됐어.
생성자에서 하면 되지 ㅋㅋ 아니;넹 
객체를 부르는 시점에서 생성자가
클래스가 만들어질때 static이 올라감.
static {
		
}
제가 알려준게 있는데 static initalize 마치 메소드처럼 해서 구현할 수 있다고.
저뒤에서 저 값들을 넣어줄꺼야
저거한다고 다른게 있냐? 없다 차이 없다. 똑같은데 그럼 왜 여기다가 넣을려고 했을까? 그 의도가 중요하지
이 질문은 답변하기 위해ㅓ서 저기에 있는 저 정보 저기 있는 저 정보를 어디에 누구에게 보관하면 좋을까?
저번에는 class에있엇고 중복에 있엇고 한번만 선언하기위해서 이 클래스를 둔건데
여기에 할려고 했다가 이거한번 같이보자 해서 순간적으로 마음을 바꿨어 바꾸면서 이시점에서 저거 알려줘야지
저걸 어디에 보관할거같아? 사실 이거부터 설명하고 할려고 했는데 00이 안온거야
어디다 보관하면 저런정보를 가장 적절하게 보관하는것이 파일이야 파일에다 보관하는거야 왜 파일에 보관하느냐
이게중요하겠지 첫번재 보안적인 이슈로 보관하는 경우가있고
두번째는 실리적인건데 만약에 저기중에 어떤 값이 바꼇다고 가정해보자 url이든 passwd든 저 코드안에 값이 있으면 컴파일 다시해야겠지 그거보다 서버를 내렷다가 다시 올려야해
더 중요한건 소스를 뒤져야한다는게 문제야 당사자가 건들이면 다행인데 퇴사하거나 휴가이거나 출장이거나 우리같은 신입생한테 시켜서 바꿨을때 시스템 전반에 어떤 영향을 줄지 모릊낳아
이런저런 이유로 외부파일에다가 저장하는것이 일반적이야. 그래서 저기다 설정을 못하는거지 왜? 파일을 읽어와야되기 때문에

3교시 11:05
JAVA IO 
IO 가 Input Stream, Output Stream
Stream은 우리말로 뭐에요? 흐름이지
stream은 여기서 byte의 흐름이라고 생각하며 ㄴ되요
input이면 들어오는거고 output이면 나가는거겟지
소프트웨어쪽에서는 뭐가 되었던간에 보이는 뭐든 byte덩어리에요
컴퓨터는 0, 1 밖에 모르기때문에 전체가 byte 
영상 음성 사진 모든것들이 byte
어떤 바이트 들이 있어요 source라고 합시다. 이 소스에 뭐가 막 있는거지 영상일 수도잇고 음성일 수도있고
소스가 있으면 목적지인 destination이 있겠죠 여기있는것을 일로 옮기는거지 우리말로 하면 카피
어떻게 가면 stream을 통해서 가는데 두가지 IO 두가지 빨대를 딱 꽂아 어디에 꽂냐면 소스에 꽂았지 쭉쭉 빨아서 읽어들이잖아 여기서 이 빨때를 input Stream
쭉빨아서 목적지에 뱉어야겟지 이게 output Stream 두가지 밖에 없어. 
그래서 자바에서도 Input Stream Output Stream 클래스가 있어 이게 IO에서 가장 높은 단계의 클래스 Exception처럼
근데 특별한 거는 text Stream. text라면 encoding문제가 존재. text는 좀 특별한형태여서 따로 둔다 
text는 똑같아 읽어들이는 거는 Reader 쓰는거를 Writer 용어가 그렇다는 ㅁ라
데이터가 원천에 잇는거는 Input Stream, Reader
목적지에 가는거는 Output Stream, Writer
text에 한해 젤 높은건 Reader, Writer
이 스트림이 뭐냐 따라서 이름이 다르게 가져감
저 소스가 만약에 메모리에서 가져온다면 메모리에관련된 이름이 붙음
네트워크에서 가져오면 네트웤에 관련된 이름이 붙고
저 스트림 잘 아는게 파일 
파일은 사실 스트림 덩이리인거지 파일은 스트림을 모아논 특별한 포멧인거지.
우리는 무었때문에 이문제가 나왓냐면 JDBC를 처리하기 위해서 우리는 파일을 어ㄸ허게 처리할것인가
학습은 이렇게해야된다. 주어진시간에 무언가를 해야된다 1장부터 하는게 아니라 들어가서 주어진프로젝트를 문제로 보고
어떻게 해결한것인가를 습득하는 형태로 해야된다
가장 먼저버려야되는것은 이거 모르기때문에 이걸 모른다. 이거를 버려야된다.
학교때는 맞는데 직장때는 아니다 환경이 바뀌면 적응해야됨.
몰라도 갈 수 잇는 용기가 필요하다 

파일이 들어오면 원천이 파일이 되겟죠 
Input Stream Output Stream 자바의 최상위 클래스인데
문제는 이 두녀석이 다 추상클래스에요
추상클래스면 구체성이 등장해야겠죠
Employee가 추상이면 그 밑에 실제 Employee가 나와야겠지 저밑에 어딘가에 만들어진 놈이 있겟지 라고 생각해야ㅗ디
file과 관련된 저기 밑에 녀석이 FileInputStream이에요 이름그대로
file을 쓰겟다 이름 그대로 FileOutputStream
file이 text라면 FileReader, FileWriter
생성자에 인자가 있어 인자에는 읽어야될 파일의 경로 위치 정보 데이터 정보는 String 
그 파일을 가지고 또 클래스로 가버렷 이차 평면상에 우리가 좌표를 가질때 x,y좌표만 있으면되지 int x, int y좌표
근데 이게 어떻게 OOP에서 생각하냐면 이걸 다시 한번 캡슐화 좌표가 . 영어로 point 
OOP는 기본적권느에서 한번더 나아가게 됨. 그래서 C가 먼저 나왔음 C는 우리 인간의 본능적 요소 JAVA는 다시 한번더 인간적인 모습.
필통. 연필 가방에 넣으면아노디나? 비밀봉다리에 넣으면 안되나? 근데 필통에 넣는다.

저기에 문자열이 왔다고 했죠 그거를 캡술화 하는것이 File이라는 클래스다 이 클래스안에 path가 있고, 확장자, 사이즈 종류가 많아졋잖아
많아지니간 둘 수 없겠지 그래서 File이 있다. 저걸 이요해서 넣어도되고 문자로 해서 넣어도 된다. 
Input이라는건 뭘까 뭐가 Input될까요 뭐가 나올가요 Stream은 byte를 읽는거다.
byte를 읽으면 byte는 몇비트? 8비트
캐릭터는 바이트 2개 16비트 
자바에 int short long 
int = 2^32 부호비트가 있어서 2^31 대략 21억 4바이트 
그앞에는 16
그앞에는 8
그뒤에는 64

double은 8바이트

캐릭터는 a를 쓰든 가를 쓰든 2바이트이다. 

바이트 읽어 들였다 한바이트씩 read 쓴다 wirte 
Input에는 read라는 메소드가 있고
Output에는 write라는 메소드가 있다.

read라는 메소드의 인자로 바이트가 들어간다 바이트가 들어가니깐
write 바이트가지고 써야되겠지.

캐릭터는 뭐가들어갈까 캐릭터가 들어가야지
캐릭터가 읽으면 캐릭터가 들어가고 바이트읽으면 바이트

패키지이름은 java.io패키지
클래스에 input stream

read(byte[] b)
이런걸 뭐라하냐면 buffer
io는 거의 대부분 buffer를 쓴다.
얘는 좀 더러워
00하고 xx하고 내기를 합니다. 어떤 내기냐하면 여기에 각각 주스가 하나 있어요 병에 담긴 주스를 목적지의 빈병에다가 다 채워 넣어야 되요
채워넣는데 조건이 있어요 특정 한 부분만 그니깐 지정된 한곳만쪽빨고 뱉어내야돼. 몇번 왔다갔다해야돼 엄청 해야겠지 빨리하는사람이 이기는 경기지
여기에 조금 머리를 쓰게 되어서 반칙을 허용한다. 쭊빤다음 볼에 가득채워서 뱉으면 되지 이 볼따구가 buffer그냥 read하면 1바이트 읽는데
buffer는 채워서 가라. buffer를 채우는것이 빠르다.

리턴이 int인데 byte로받아서 왜 int냐 특별한 이유가 있는건 아니고 원래 byte가 8바이트지만 다 못쓰죠 부호비트때문에 안맞아서 int를 쓰는거에요.
읽어들이면 다 양수값들이에요 우리가 쓰는 byte는 음수도 표현하는데 이 바이트는 다 양수 

write는 read와 쌍으로 간다 인자있고 비슷비슷하다 이제 뭐하냐면 fileInputStream

fileInputStream의 아버지는 InputStream 추상이 아니다 직접 쓸수 있따.
쭉 보면 생성자를 한번 보세요. 생성자를 보면  인자가 잇으니 만ㄷ르면 반드시 인자를 써야된다.

fileInputStream(String name)
name - 시스템 특성적인 파일정보를 넣는다는 뜻.

일단은 저기 있는 file이라는 리소스를 얻기위해서는 빨대는 필요하다 빨대역활을 하는 fileInputStream을 만들고 인자로 C:/temp/memo.txt이런식으로 들어간다.
그럼 여기다 대고 빨대를 꽂았어 그다음 read 하면 하나씩 읽는다 다할때까지 읽어야한다. read는 return값을 줘야겟따 알아야되니깐 return값은 int
어떤 문제영역에서 우리가 필요로하는 뭘 만들때 이거 할때 뭐가 필요하지 어떻게 해야돼? 우리 프로젝트때 해야되고 이 결과로 클래스 메소드가 정의됨.
이 return은 현재 내가 읽은 바이트가 리턴 10을 읽으면 10을 리턴.
다읽었으면 더이상 없으면 -1을 return. -1을 만나게 되면 다읽었따 while이나 for를 사용 계속 돌리다가 -1을 만나면 다 읽엇따.
read 계속 반복되어야겠죠 언제까지? -1을 만날때까지
쭉쭉쭉 빨아댕겻다 빨면 다 뱉어내야되느냐 그건 아니다 file로 읽엇따고 해서 꼭 file로 가라는 법은 없다. file로 읽은것을 console에다가 뿌리고싶어 말되지
어떻게 뿌리냐면 console이 일종의 표준출력모드로 해라 그 클래스가 PrintStream이에요 내가 읽었떤것이 여기 안찍고 file에다가 쓰겟다 소위 말하는 copy

우리는 db에관련된 정보를 읽는데 이정보가 파일에 있다 읽어들였어 java에다가 주려고하는거지. static final에다가 넣을려고 하는거야 

12:10 4교시
file과 관련되 모든것들은 IOException이 발생 checked Exception
try catch로 만들어줘야됨 지금 에러는 아직 그 함수를 안부르고 했기때문
데이터베이스는SQLException file은 IOE checked 수백번 이야기함
close시킨거 기억나세요? 모든 IO들은 연결을 하면 끊어줘야합니다.

close조차도 IOException발생하죠? 쓰고나면 닫아야된다.
FileInputStream객체를 만듭니다.
FileInputStream fis = null;
		int totalByes = 0;
		try {
			try {
				fis = new FileInputStream(null);
			} finally {
				fis.close();
			}
			
		} catch (IOException e) {
			e.printStackTrace();
		}
}
null에 파일의 패스를 쓰는데 지금은 간단하게 test.txt
자 읽어ㅑㅇ됩니다 for문 돌립니다.
for(int readByte; (readByte = fis.read()) != -1;) {
					
}
for문을 이렇게 쓸수도있다 i++이런게 없죠 그럼 뭘가지고 그럴까 비교가? for문에 2번재에 있다 
i가 뭐보다 작을때 이렇게 즉 fis.read하게되면 return타입은 int인데 readByte에 담아.
그 값이 -1이 아니다. (읽을때) 아니면 다 참이니깐 참 동안 계속 for문을 돌린다.

System.out.write(readByte); 
totalBytes++;
찍어보자

하나읽고 올리고 하나읽고 올리고 totalBytes가 읽은 바이트의 수.

절대주소는 앞에 / 없으면 상대주소.

file test.txt 생성

실제 글자가 어떤바이트는 2바이트 어떤거는 3바이트까지 쓴다
왜냐면 글자를 표시하는 방법이 숫자로 맵핑되어야되는데 영어입장으로 보면 이 키보드는 128이라는 셋안에 다집어넣을수 있다
한자는 자기만 가지고있는게 10만자가 넘어 다 못집어 넣는다고 128보다 더큰 숫자 범위를 필요로해 
예를 들어 가는 25525이런식으로 표시해야된다고 같은 영어 표현은 한바이트로 충분하고 한자는 쓰리바이트가 필요
야 우리가 쓰면 문제없는데 니네까지하려니 메모리가 더 필요하고 바이트가 더필요하고 이렇게 나오겠죠
전체적으로 나오려면 쓰리바이트하자 이러면 국제적으로 처리할 수 있겠죠 근데 쟤네는 좋긴한데 인종차별은 아닌데
효유ㅜㄹ적으로 할수 있지 않겟냐 여기서부터 여기는 한바이트 여기서저기는 이바이트 이게 인코딩 
인코딩이 다르면 글자가 깨지게 된다 옛날에는 이문제가 첨예한 문제였고 첫 프로젝트때 메일만든다고햇죠
웹메일 야후가 던지는거 뭐 던지는거 구분없엇고 다음이 던지는거 메일이 다 달라가지고 여기서는 나오는데 여기서는 깨져
ㅁ치ㅣ고 환장하겟다고 여기서맞으면 여기가 깨져 그때는 중구난방이었다 그러다가 전세계가 뭘로 통합되냐하면 utf-8로 통합되어져요 지금은 그냥 utf-8로
왜 이렇게 햇을가 했을때 무머ㅝ 해서 복잡성이 대조 뭐 어쩌고 저쩌고 뭐 어쩌고 저쩌고 ios힘도 못쓰고 저쩌고 햇는데
내생각을 달라 이유가 자바스크립트시간때 ajax가 대두되면서 다 utf-8로 바꾸ㅢㄴ게 아닐까 새로운 기술이 개발되고
개발자들은 사용해야되잖아 소프트웨어 우리가 만들고 내가 이거 쓰고싶은데? 근데 그게 utf-8이거든 사장은 몰라도그냥 휩쓸어버린거죠
거진 다 utf-8이에요
파일로 만들 수 이씅ㄹ까요?
쓰는곳을 바꾸면 되겟죠
System.out.write(readByte); 이부분을 FileInputStream으로 바꾸면 쓰는거에요 
폴더에 파일하나를 복사해서 드래그하면 복사되죠? 이게 보이는거고 그안에는 개발자들이 fileInputStream fileOutStream이 다 있는거에요
일반사람들은 이런게 동자ㅣㄱ하는지 몰라
잘들어봐 이렇게 드래그해서 복사하게해서 시킨놈이 뛰어난놈일까 그렇게 만든놈이 뛰어난놈일까 동작한놈이 더 받는다
구현을 걔가 하잖아
자동차를 생각해보면 다 거기서 거기잖아 근데 전기차가 들어오면서 바꼇죠 뉘앙스가
왜 못만들었을까 생각한 사람이 있엇어 근데 안만들잖아 왜안만들까 구현을 못하기 때문에
구현만 되면 왜 자동차 저렇게 만들가 스타워즈처럼 만들지

ufo는 동그래 전투기는 새모양인데 이상하지않아? 공기역학적으로 보면 뾰족해야되자나
공기흐름하고 두개의 차이로 뜨는거란 만ㄹ이야 근데 ufo는 둥그래서 날개도 없잖아 왜안만들어?
못만드는거지 

모두가만들면 뭐가 문제일까요 file을 옛날에는 이렇게 복사했어요 copy 어디어디 뭐를 d드라이브에 어디어디에 넣어라
그렇게 하다가 이제 이렇게 하잖아요 그러면 이렇게 생각한사람이 돈버는거에요 그 세부내용이 똑같다면
그상상을 하는 사람이 돈 버는거에요 잡스가 이야기한거 해볼까요 이사람이 엔지니어 아니에요 우리말로 하면 문과생이라고
문과생이고 말그대로 타이퍼그래피 글자 만 한사람 그 it를 인문학적으로 보기좋게 형태를 생각한사람
폰트 즉 미학을 집어넣은사람 이사람이 뭘만들려고햇냐면 동영상플레이어를 만들려고햇어요 누가 젤잘만들어
독일 누가누가가 대가입니다 회사사거나 그사람 사거나 해 이사람이 잡스의 부름을 받습니다. 드디어 잡스를 대독을하고 만나는구나
회사를 방문합니다. ㅎ잡스를만나로 갑니다 말끔하게 차려입고 인사하고 할줄알앗는데 드가니깐 일하고잇더래 쭈뼈ㅑㅅ하니깐 누구냐
독일에서 영상만드는 개발자가 잡스가 어 잘왔다 이러면서 이 사람한테 자 여 봐봐 여기에 화면이 있어 이 화면안에 박스가 있다 
여기 영상을 집어넣어서 플레이시켜 가서 일해 저 생각은 기술을 아는 사람은 불가능한 기술이에요 당시에 잡스가 엔지니어엿다면 말안햇을거다
누가 위대할까 잡스? 이사람? 우리는 이사람이 위대하다고 해야돼  개발자잖아 이사람이 위대한거지. 안그래? 여러분들이 해야될거라고
근데 세상은 저사람 안알아주죠 모든 공은 잡스한테 가는거야 모든 공은 잡스가 만들엇다 아이폰도 애플도 맥도 뭔 개소리야 ㅋㅋ
얼마나 개발자들이 울면서 나갓는데 모진말을 들으면서 전기보세요 키보드 던지면서 
근데우리는 찰것도 없어 소프트개발자는 하드웨어는 니들이 찰 수잇는거 ㅋㅋ 그외에는 다 소프트웨어야 우리는 그런 직업을 가지고 잇음
나설수가 없는 직업 스포트라이트를 바등ㄹ수 업슨 ㄴ직업. 여러분들이 구글회장이누군지는 기억못할수잇지만 알파고를 만든 머리없는 젊은새끼는 기억함 ㅋㅋ
티셔츠도 예산ㄹ가팅 이상한거아니고 개발코드라던지 커뮤니티문화를 형성하면서 


2:11 5교시
public class FileInputStreamTest {
	public static void main(String[] args) {
		FileInputStream fis = null;
		FileOutputStream fos = null;
		int totalBytes = 0;
		try {
			try {
				fis = new FileInputStream("test.txt");
				fos = new FileOutputStream("test_copy.txt");
				for(int readByte; (readByte = fis.read()) != -1;) {
					fos.write(readByte);
					totalBytes++;
				}
			} finally {
				fos.close();
				fis.close();
			}
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println("전체 바이트 수: " + totalBytes + " bytes.");
	}
}

반대로 닫아줘야한다 아니면 누수가 남.
JDBC의 관련 정보들을 어떻게 보관할까? it에서는 특별히 고민할 필요가 없다 이미 있었더 ㄴ고민이기 때문에
보관하고자 하는 대상 즉 지금같으면 JDBC URL이다 URL = 블라블라 적어주는게 가장 간단하다.
=의 왼쪽은 키값이 되고 오른쪽은 값이된다. 통상적으로 키와 값을 = 표현하는 방식을 property라고 하고 확장자고
properties라고 만든다. 
앞에서했던거를 JDBC_DRIVER 는 com.블라블라 JDBC_URL 은 뭐라뭐라 이런식으로 할텐데
이런방식을 좀더 쉽게할 수 있는 방식 map이 있다. 
map이 키와 밸류를 묶어서 보관하는 자료구조 key는 Object 오직 String만 보관할수 있는 클래스가있는데
Properties클래스이다 우리느 ㄴ이거를 이용해볼거에요 이걸 이용하면 더 손쉽게 빠르게 처리할 수 잇다.

private static final String JDBC_URL;
private static final String JDBC_USER;
private static final String JDBC_PASSWD;

여기로 돌아ㅗ아서
static {
	Properties props = new Properties(); //추가
	props.load(InputStream inputStream) //다형성
}

	static {
		Properties props = new Properties();
		try {
			props.load(new FileInputStream("jdbc.properties"));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

props가 map같은거에요 map에는 키값이 있잫ㄴ아요
props.getProperty("JDBC_URL"); 읽어들인것을

	static {
		Properties props = new Properties();
		try {
			props.load(new FileInputStream("jdbc.properties"));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		JDBC_URL = props.getProperty("JDBC_URL");
		JDBC_USER = props.getProperty("JDBC_USER");
		JDBC_PASSWD = props.getProperty("JDBC_PASSWD");
	}

jdbc.properties가 있어야겠죠
만ㄷ르어보겟습니다.

jdbc.properties 작성

	JDBC_DRIVER=com.mysql.cj.jdbc.Driver
	JDBC_URL=jdbc:mysql://localhost:3306/jv250?serverTimezone=Asia/Seoul
	JDBC_USER=jv250
	JDBC_PASSWD=jv250
	
	
드라이버도 매번 생성자마다 로드되고있죠 한번만 하면되죠 가져와서 바로 해버리는 거죠
public class DataSourceManager {
	private static final String JDBC_URL;
	private static final String JDBC_USER;
	private static final String JDBC_PASSWD;
	
	static {
		Properties props = new Properties();
		try {
			props.load(new FileInputStream("jdbc.properties"));
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		try {
			Class.forName(props.getProperty("JDBC_DRIVER"));
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		
		JDBC_URL = props.getProperty("JDBC_URL");
		JDBC_USER = props.getProperty("JDBC_USER");
		JDBC_PASSWD = props.getProperty("JDBC_PASSWD");
		System.out.println("JDBC_URL = " + JDBC_URL);
	}
	
	public static void main(String[] atrgs) {
		DataSourceManager manager = new DataSourceManager();
	}
} 

이제부터 중요합니다.
자 이렇게 하면 우리가 앞에서 했던 중복문제가 사라지겠죠 스태틱은 한번밖에 안불리니깐 로딩도 한번하고
중요한건 처리하는 시점이 중요한거야 이게 굉장히 오랜시간이걸리는 작업이라고 생각해봅시다
요청이들어왓고 처리하는 과정에서 저코드를만나게되고 저 코드가 굉장히 오래걸린다고 가정하면 
느끼는사람은 굉장히 느리다고 생각하겠죠 아주 큰 리소스의 작업을할때 느려집니다. 저거를 서버스타트해서 올ㄹ릴때
작업합니다. 아직 서비스를 제공하기전이니깐 막 작업합니다. 윈도우 로딩할때마다 오래기다려야되죠 먼저 인프라를 처리하겟다는거죠
근데 사람들에게 불평이 들어오게되죠 근데 비교불평입니다 다른 OS가 그 시간을 짧게 만들어버리면 욕을먹기 싲가합니ㅏㄷ.
근데 태블릿이 등장합니다 버튼만누르니 시작되니 윈도우입장에서는 이타임을 짧게 가져가려고 노력하죠
지금 11 올리면  8,7,vista비교하면 빠르죠 이제는 끄지마라 그러죠 안끕니다 요즘은 애플이 누르면 뚜껑닫으면 슬립모드로가잖아요
경쟁자가 그러니깐 여기도 그러는 거죠 지금 내가보기에 윈도우 전원체제는 개판입니다. 
디비를 4번을 날렷습니다 mysql이 비정상적으로 셧다운됐을때 log를 쓰거든요 log를 쓰기 이전에 셧다운되어버리면 싱크가 안맞아서 죽어버립니다.
mysql문제인지 window문제인지 모르겟지만 원인을제공한건 window잖아요 
그렇기때문에 여기 static이부분도 class가 로드될때 처리되는거죠 아무것도안해도 class가올라갈때 처리되죠
두번째의 문제는 앞에서 했떤 내용중엣어 옵션인데 조금 귀찮은거 제거좀 해보겠습니다. 일단 customerdao 카피해볼까요

생성
	public Connection getConnection() {
			
	}


	public static Connection getConnection() throws SQLException {
		return DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWD);
	}

이렇게 쓰고

con = DataSourceManager.getConnection(); 교체

Connection까지도 해결했다.
지금처럼 DataSourceManager.getConnection(); 두개의 차이?
자 지금 DriverManager할때는 getConnection받아왔지 매번 받고 연결하고 쿼리날리고 클로즈하고 또 호출하면 또 연결하고 쿼리날리고 호출하고
지난번에 이런이야기 했는지 모르겟는데 데이터베이스는 실제 처리하는것보다 연결하는게 시간이 더걸려 그래서 미리 연결된거를 만들어둬 이거를 Connection pool이라고 하는데
몇개를 만들어둔다고 작게는 5개 몇십개까지 만들어준다고 그때가서 연결하는게 아니라 만들어둔거 줘버려 끊지않고 다시 살려 근데 지금 여전히 getConnection이지 그렇지만
dao가 그거를 모르는거지 자기가 pooling을 활용해 받는건지 getConnection활용해 받는건지 그 이야기는 나중에 Connection을 바꾸더라도 코드가 변경이 안된다고는 것이ㅑㅇ
그냥 얘는 받아오는 거야 얘는관심없어 예쩐에는 얘ㅖ가 그걸 해야되는거거든 지금은 순수하게 이 로직만 활용할거야 그 외에 모든거는 니가 다해(커넥션받아오고 로딩하고) 나중에 프레임웤이라는게
여러분한테 뭘시킬거같에? 뭘시킬거같냐면 이거는 이관련된 부분은 저기 있는 사람이든 삼성이든 저거는 똑같지 근데 여기있는 이부분은 내가 뭘짜냐에 따라서 달라지지 이거는 우리만에 문제(로직)
저거 다 동잃나문제(Connection) 프레임 웤이 해결한는건 저문제 (Connection) 그자체로는 의미가없다 그것을 가져다가 이문제를(로직) 해결하겟다 나주엥 Spring 배우면 지금까지짠코드의
절반으로 줄어든다 Dao는 Data access Object  근데 엄청나게 저 쿼리를 쓰는데 저 쿼리를 누가 쓰고 있지 개발자가 쓰고있지 개발자는 개발자 프로그램짜는사람이지 데이터전문가가 아니야
근데 회사에 엄청난 데이터전문가 디비코더가 있다면 저사람이 저코드를짜는게 훨씬잘해. 근데 이사람은 문제가뭐냐면 자바를 모른다는거지 자기가 하는건 쿼리잖아. 그래서 어떻게 하냐면 그 쿼리만 들어내서
여기다가 적으세요 이사람은 쿼리만 치면 xml로된 포맷이있어 ㄱ거기다 치면 나는 그 xml을 읽어들이는 객체가 있어. JPA는 뭔쿼리여 ㅋㅋ 야 쿼리 잘짜는데 얼마주냐 뭔커리여 그러지말고 쿼리를 컨테인에다 만들어준대
기계가 만들어 대신 나한테 쿼리를 만들수있는 metaData를 줘 예를들어 Customer table안에 name을만들어줘 뭐라면 뭘 해줘 뭐라면 뭘해줘 어라 자바네? 그러면 그 정보를 읽어서 바로 Create Select 다해줄게
너는 그거만 만들어 그러면 데이터전문가가 날라가 지금은 그렇게해 생산성때문에. 원래 sql로작성한거하고 기계가 만든코드하고 sql이 빨라 근데 이런 사람들을 키우기가 힘들도 두번재는 생산성이야 기업은 생산성이 엄청중요하거든
그러면서 동시에 얘가 완전하지않아 그랫더니퍼포먼스가 안나와 기계는 거짓말안해 이쪽으로계속 발달을 시키는거지. 한때는 느리다고 이야기가 나왔는데 내가 짠 이 자바로짠 이 프로그램이 jdbc보다 느리다고 증명하면
$100 주겟다 근데 아무도 없슴 그러니깐 일종의 선입견 쿼리는 사람이 직접보고 써야된다. 지금은 기계가 더정확하게만들어 기계는 실수를 안해 그러면 나머지 우리에게 요구하는 능력은 이제 우리가 뺏는거지
우리가 클래스를 만들면서 많은 부분들을 대체를 하는거지 우리가 공부할게 많아지는게 문제. 회사입장에서봤을때 월급이 나한테오나? 회사는 개꿀이다 항상 승리자는 회사 
지금은 젤 낮은곳에 있기때문에 수혜자지만 언젠가 더나은 프레임웤 우리후배들이 배우겟지 그때 우리 경쟁력은? 그니깐 너무 이 기술에 취하지마라 사람들은 착각하고있어 여기서 요 코드를 짜고있지만
야 뭔 코드여 // 나는 마이바티스 하는데 // 난 jpa하고있는데? 자기가 더높은 기술을 가지고 있다고 말하고있는거야 근데 1+1 푸는데 누군가는 연필 주판 계산기 컴퓨터 여기서 기술의 진화가 있엇나?
없다 1+1 = 2 여기서 기술진화는 주판을 만든사람 계싼기 만든사람 컴퓨터만든사람이 기술 진화 사용자는 진화한게아니다 여러분들이 Spring만든게 아니라 도구를 사용하는거잖아 
착각이다 여전히 1+1에 머물고있다. 좀 지나면 새로운 프레임웤 쓰고 배우고 회사는 단물빨고 그니깐 잘 해야돼.
이제 나머지가 뭐냐면 close도 계속 반복이지 없앨수 있겟어?

